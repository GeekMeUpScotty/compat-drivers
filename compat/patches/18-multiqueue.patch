The 2.6.23 kernel added multiqueue support. That release
relied on the on the notion of struct net_device_subqueue
attached to the netdevice struct as an array. The 2.6.27
renamed these to struct netdev_queue, amogst other changes.

For kernels 2.6.23..2.6.26 then we backport MQ support by
using the equivalent calls on the struct netdev_queue to
the struct net_device_subqueue.

For older kernels than 2.6.23 we can only stop all the
queues then.

--- a/net/mac80211/util.c	2010-01-20 18:35:04.000000000 -0800
+++ a/net/mac80211/util.c	2010-01-20 18:34:11.000000000 -0800
@@ -287,7 +287,13 @@
 
 	rcu_read_lock();
 	list_for_each_entry_rcu(sdata, &local->interfaces, list)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
 		netif_tx_wake_queue(netdev_get_tx_queue(sdata->dev, queue));
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23))
+		netif_start_subqueue(sdata->dev, queue);
+#else
+		netif_wake_queue(sdata->dev);
+#endif
 	rcu_read_unlock();
 }
 
@@ -322,7 +328,13 @@
 
 	rcu_read_lock();
 	list_for_each_entry_rcu(sdata, &local->interfaces, list)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
 		netif_tx_stop_queue(netdev_get_tx_queue(sdata->dev, queue));
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23))
+		netif_stop_subqueue(sdata->dev, queue);
+#else
+		netif_stop_queue(sdata->dev);
+#endif
 	rcu_read_unlock();
 }
 

ksize() was added as of 2.6.29, it gives you the actual
size of the allocated data. Since we have no support for
this we simply do not optimize for it and deal with
large alloocations for the IEs.

We technically could backport this as

define ksize(bleh) SOME_LARGE_NUMBER

but doing it this way emphasis careful review
of the situation.

--- a/net/wireless/scan.c
+++ b/net/wireless/scan.c
@@ -427,9 +427,14 @@ cfg80211_bss_update(struct cfg80211_regi
 			size_t used = dev->wiphy.bss_priv_size + sizeof(*res);
 			size_t ielen = res->pub.len_proberesp_ies;
 
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,28)
+			if (0) {
+				used = 0; /* just to shut up the compiler */
+#else
 			if (found->pub.proberesp_ies &&
 			    !found->proberesp_ies_allocated &&
 			    ksize(found) >= used + ielen) {
+#endif
 				memcpy(found->pub.proberesp_ies,
 				       res->pub.proberesp_ies, ielen);
 				found->pub.len_proberesp_ies = ielen;
@@ -460,9 +465,14 @@ cfg80211_bss_update(struct cfg80211_regi
 			size_t used = dev->wiphy.bss_priv_size + sizeof(*res);
 			size_t ielen = res->pub.len_beacon_ies;
 
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,28)
+			if (0) {
+				used = 0; /* just to shut up the compiler */
+#else
 			if (found->pub.beacon_ies &&
 			    !found->beacon_ies_allocated &&
 			    ksize(found) >= used + ielen) {
+#endif
 				memcpy(found->pub.beacon_ies,
 				       res->pub.beacon_ies, ielen);
 				found->pub.len_beacon_ies = ielen;

The 2.6.29 kernel has new struct dev_pm_ops [1] which are used
on the pci device to distinguish power management hooks for suspend
to RAM and hibernation. Older kernels don't have these so we need
to resort back to the good ol' suspend/resume. Fortunately the calls
are not so different so it should be possible to resuse the same
calls on compat code with only slight modifications.

[1] http://lxr.linux.no/#linux+v2.6.29/include/linux/pm.h#L170

--- a/drivers/net/atl1c/atl1c_main.c
+++ b/drivers/net/atl1c/atl1c_main.c
@@ -2881,6 +2881,34 @@
 	.resume = atl1c_io_resume,
 };
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29))
+static int atl1c_suspend_compat(struct pci_dev *pdev, pm_message_t state)
+{
+	int r;
+
+	r = atl1c_suspend(&pdev->dev);
+	if (r)
+		return r;
+
+	pci_save_state(pdev);
+	pci_disable_device(pdev);
+	pci_set_power_state(pdev, PCI_D3hot);
+	return 0;
+}
+
+static int atl1c_resume_compat(struct pci_dev *pdev)
+{
+	int r;
+
+	pci_restore_state(pdev);
+	r = pci_enable_device(pdev);
+	if (r)
+		return r;
+
+	return atl1c_resume(&pdev->dev);
+}
+#endif
+
 static SIMPLE_DEV_PM_OPS(atl1c_pm_ops, atl1c_suspend, atl1c_resume);
 
 static struct pci_driver atl1c_driver = {
@@ -2890,7 +2918,12 @@
 	.remove   = __devexit_p(atl1c_remove),
 	.shutdown = atl1c_shutdown,
 	.err_handler = &atl1c_err_handler,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 	.driver.pm = &atl1c_pm_ops,
+#elif defined(CONFIG_PM_SLEEP)
+	.suspend        = atl1c_suspend_compat,
+	.resume         = atl1c_resume_compat,
+#endif
 };
 
 /*
--- a/drivers/net/wireless/ath/ath5k/base.c
+++ b/drivers/net/wireless/ath/ath5k/base.c
@@ -3717,6 +3717,34 @@ static int ath5k_pci_resume(struct devic
 	return 0;
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29))
+static int ath5k_pci_suspend_compat(struct pci_dev *pdev, pm_message_t state)
+{
+	int r;
+
+	r = ath5k_pci_suspend(&pdev->dev);
+	if (r)
+		return r;
+
+	pci_save_state(pdev);
+	pci_disable_device(pdev);
+	pci_set_power_state(pdev, PCI_D3hot);
+	return 0;
+}
+
+static int ath5k_pci_resume_compat(struct pci_dev *pdev)
+{
+	int r;
+
+	pci_restore_state(pdev);
+	r = pci_enable_device(pdev);
+	if (r)
+		return r;
+
+	return ath5k_pci_resume(&pdev->dev);
+}
+#endif
+
 static SIMPLE_DEV_PM_OPS(ath5k_pm_ops, ath5k_pci_suspend, ath5k_pci_resume);
 #define ATH5K_PM_OPS	(&ath5k_pm_ops)
 #else
@@ -3728,7 +3756,12 @@ static struct pci_driver ath5k_pci_drive
 	.id_table	= ath5k_pci_id_table,
 	.probe		= ath5k_pci_probe,
 	.remove		= __devexit_p(ath5k_pci_remove),
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 	.driver.pm	= ATH5K_PM_OPS,
+#elif defined(CONFIG_PM_SLEEP)
+	.suspend        = ath5k_pci_suspend_compat,
+	.resume         = ath5k_pci_resume_compat,
+#endif
 };
 
 /*
